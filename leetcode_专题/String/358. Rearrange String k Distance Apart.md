Given a string `s` and an integer `k`, rearrange `s` such that the same characters are **at least** distance `k` from each other. If it is not possible to rearrange the string, return an empty string `""`.

 

**Example 1:**

```
Input: s = "aabbcc", k = 3
Output: "abcabc"
Explanation: The same letters are at least a distance of 3 from each other.
```

**Example 2:**

```
Input: s = "aaabc", k = 3
Output: ""
Explanation: It is not possible to rearrange the string.
```

**Example 3:**

```
Input: s = "aaadbbcc", k = 2
Output: "abacabcd"
Explanation: The same letters are at least a distance of 2 from each other.
```

 

**Constraints:**

- `1 <= s.length <= 3 * 105`
- `s` consists of only lowercase English letters.
- `0 <= k <= s.length`

```
class Solution {
 public String rearrangeString(String s, int k) {
        if(k==0) return s;
        int[] freq = new int[26];
        StringBuilder ans = new StringBuilder();
        for (char c : s.toCharArray()) freq[c - 'a']++;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);
        for(int i = 0; i < 26; i++) if(freq[i] > 0) pq.add(new int[]{i, freq[i]});
        Queue<int[]> q = new LinkedList<>();
        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            ans.append((char)(current[0] + 'a'));
            current[1]--;
            q.add(current);
            if (q.size() >= k) { 
                int[] front = q.poll();
                if (front[1] > 0) pq.add(front);
            }
        }
        return ans.length() == s.length() ? ans.toString() : "";
    } 
}
```

