Given an array of non-negative integers `nums`, you are initially positioned at the **first index** of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

 

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
```

 

**Constraints:**

- `1 <= nums.length <= 3 * 104`
- `0 <= nums[i] <= 105`

Backtracking : Time Limit Exceeded

```
class Solution {
    public boolean canJump(int[] nums) {
        return helper(nums,0);
    }
    public boolean helper(int[] nums,int pos){
        if(pos==nums.length-1) return true;
        int furpos=Math.min(nums[pos]+pos,nums.length-1);
        for(int next=pos+1;next<=furpos;++next){
            if(helper(nums,next)) return true;
        }
        return false;
    }
}
```





dp

```
class Solution {
    public boolean canJump(int[] nums) {
        int len=nums.length;
        String[] dp=new String[len];
        for(int i=0;i<len-1;++i){//initialize dp array
            dp[i]="unknown";
        }
        dp[len-1]="good";
        for(int i=len-2;i>=0;--i){
            int fur=Math.min(i+nums[i],len-1);
            for(int j=i+1;j<=fur;++j){
                if(dp[j].equals("good")){
                    dp[i]="good";
                    break;
                }
            }
        }
        return dp[0]=="good";
        
    }
}
```





greedy

```
class Solution {
    public boolean canJump(int[] nums) {
        int pre=nums.length-1;
        for(int i=nums.length-2;i>=0;--i){
            if(i+nums[i]>=pre) pre=i;
        }
        return pre==0;
    }
}
```

```
class Solution {
    public boolean canJump(int[] nums) {
        int max_po=nums[0];
        for(int i=1;i<nums.length;++i){
            if(max_po<i) return false;
            max_po=Math.max(max_po,i+nums[i]);
        }
        return true;
    }
}
```

