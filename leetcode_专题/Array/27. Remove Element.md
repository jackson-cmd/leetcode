Given an array *nums* and a value `val`, remove all instances of that value [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) and return the new length.

Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with `O(1)` extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

**Clarification:**

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by **reference**, which means a modification to the input array will be known to the caller as well.

Internally you can think of this:

```
// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

 

**Example 1:**

```
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2]
Explanation: Your function should return length = 2, with the first two elements of nums being 2.
It doesn't matter what you leave beyond the returned length. For example if you return 2 with nums = [2,2,3,3] or nums = [2,2,0,0], your answer will be accepted.
```

**Example 2:**

```
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3]
Explanation: Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length.
```

 

**Constraints:**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`



solution 1:

快慢指针， i是慢的，j是快的，j一直走，如果有等于val的，i不动，j接着走，直到j走出了val的范围，开始更新i的值，缺点是如果val在第一个，会把整个数组改了，速度慢，而且数组最后几个还在，长度也没有改变，逻辑上不太对。

```
class Solution {
    public int removeElement(int[] nums, int val) {
        int i=0,j=0,l=nums.length;
        while(j<l){
            if(nums[j]!=val){
                nums[i]=nums[j];
                i++;
            }
            j++;
        }
        return i;
    }
}
```

`solution 2

相当于找哪个element和val不一样，然后和最后一个元素换，然后把数组长度减一，如果不把else写上，那么会不check当前是不是和之前一样，而且长度也不对。

```
class Solution {
    public int removeElement(int[] nums, int val) {
        int i=0,l=nums.length;
        while(i<l){
            if(nums[i]==val){
                nums[i]=nums[l-1];
                l--;
            }else{//一开始忘加else了，有bug
                i++;    
            }
        }
        return i;
    }
}
```













































```
class Solution {
    public int removeElement(int[] nums, int val) {
        int len=nums.length;
        int j=0;
        for(int i=0;i<len;++i){
            if(nums[i]!=val){
                nums[j]=nums[i];
                j++;
                
            }
                
        }
        return j;
    }
}
```

```
class Solution {
    public int removeElement(int[] nums, int val) {
        int ans=0;
        for(int i=0;i<nums.length;++i){
            if(nums[i]!=val){
                nums[ans++]=nums[i];

            }
        }
        return ans;
    }
}
```

